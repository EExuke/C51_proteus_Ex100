//-----------------------------------------------------------------
//  名称: PC机与AT89C52单片机双向通信
//-----------------------------------------------------------------
//  说明: 单片机可接收PC机发送的数字字符,按下单片机K1按键时,单片机
//		可向PC机发送字符串.在Proteus环境下完成本实验时,需要
//		先安装Virtual Serial Port Driver和串口调试助手软件.
//		建议在VSPD中将COM3和COM4设为对联端口.Proteus中设COMPIM
//		为COM4,在串口助手中选择COM3,完成配置后即可实现单片机程序
//		与XP下串口助手软件之间的双向通讯.
//		本例缓冲为4个数字字符,缓冲满后新接收的字符从缓冲前面存放
//		（环形缓冲）,覆盖原来放入的字符.
//		如果发送的数字串中遇到"#"号则从缓冲起始位置开始存放.
//
//-----------------------------------------------------------------
#include <reg52.h>
#include <intrins.h>
#include <stdio.h>
#define INT8U  unsigned char
#define INT16U unsigned int
#define FREQ 	11059200	//振荡器频率11.0592MHz
INT8U code SEG_CODE[] = 	//共阴数码管数字段码表,最后为"-"的段码
{ 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x40 };
INT8U R[] = {10,10,10,10};	//保存接收到的四位数字(初始时为4个"-")
//-----------------------------------------------------------------
// 延时程序
//-----------------------------------------------------------------
void delay_ms(INT16U x) {INT8U t; while(x--) for(t = 0; t<120; t++);}
//-----------------------------------------------------------------
// 串口初始化(使用Timer1定时器)
//-----------------------------------------------------------------
void Init_USART_uT1()
{
	SCON = 0x50;						//串口方式1
	TMOD = 0x20;						//T1工作于方式2（8位自动重装）
	PCON = 0x80;						//波特率不倍增
	TH1 = TL1 = - FREQ/384/9600;		//波特率配置（TH1 = TL1 = 0xFD）
	//或：TH1 = TL1 = 256 - FREQ/384/9600;
	TR1 = 1;							//启动定时器T1
}

//-----------------------------------------------------------------
// 串口初始化(使用T2定时器) (当T2CON寄存器的RCLK,TCLK二者之一置位,
// T2即工作于波特率发生器模式，TH2-TL2溢出时，RCAP2H-RCAP2L重装TH2-TL2)
//-----------------------------------------------------------------
void Init_USART_uT2()
{
	RCAP2H = 0xFF;						//波特率配置（RCAP2H = 0xFF）
	RCAP2L = -FREQ/32/9600;				//波特率配置（RCAP2L = 0xDC）
	//或：RCAP2L = 256 - FREQ/32/9600;
	SCON = 0x50;						//串口方式1
	T2CON = 0x30;						//收发时钟位：RCLK,TCLK同时置位
	PCON = 0x00;						//波特率不倍增
	TR2 = 1;							//启动定时器T2
}

//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main()
{
	INT8U i;						
	Init_USART_uT2();				//串口初始化（使用Timer2定时器）
	//或：Init_USART_uT1();
	EX0 = 1;						//允许外部中断0
	IT0 = 1;						//下降沿触发
	ES = 1;							//允许串口中断
	EA = 1;							//开中断
	while(1)						
	{
		for (i = 0; i < 4; i++)		//循环扫描显示4个数字字符
		{
			P0 = 0x00;				//先暂时关闭段码
			P2 = ~(1 << i);			//发送位码（共阴）
			P0 = SEG_CODE[R[i]];	//发送段码
			delay_ms(4);			//位间短暂延时
		}
	}
}

//-----------------------------------------------------------------
// 串口接收中断
//-----------------------------------------------------------------
void receive_4_digit() interrupt 4
{
	static INT8U i = 0;	  				//接收缓冲索引（静态变量）
	INT8U c;							//当前接收到的字符
	if (RI)								//接收中断标志位判断
	{
		RI = 0;							//软件清零中断标志位
		c = SBUF;						//从SBUF寄存器读取字符
		if (c == '#')					//接收时遇到'#'则将接收索引清零
			i = 0;
		else									   
			if (c >= '0' && c <= '9')	//遇到数字0~9时从当前位置循环存放
			{
				R[i++] = c - '0';		//存入R数组当前位置，索引递增
				if (i == 4)
					i = 0;				//归0回头
			}
	}
}

//-----------------------------------------------------------------
// INT0中断发送字符串
//-----------------------------------------------------------------
void EX_INT0() interrupt 0 
{
	INT8U *s = "这是由8051单片机发送的字符串!!!\r\n";
	INT8U i = 0;
	while( s[i] != '\0')
	{
		SBUF = s[i++];		 //发送1字节，索引递增
		while(TI == 0);		 //等待发送完毕
		TI = 0;				 //软件清零中断标志位TI
	}



}