C51 COMPILER V9.02   MAIN                                                                  02/08/2020 17:48:11 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Users\99702\Documents\keil\C51\BIN\C51.EXE main.c DEBUG OBJECTEXTEND

line level    source

   1          //-----------------------------------------------------------------
   2          //  名称: PC机与AT89C52单片机双向通信
   3          //-----------------------------------------------------------------
   4          //  说明: 单片机可接收PC机发送的数字字符,按下单片机K1按键时,单片机
   5          //              可向PC机发送字符串.在Proteus环境下完成本实验时,需要
   6          //              先安装Virtual Serial Port Driver和串口调试助手软件.
   7          //              建议在VSPD中将COM3和COM4设为对联端口.Proteus中设COMPIM
   8          //              为COM4,在串口助手中选择COM3,完成配置后即可实现单片机程序
   9          //              与XP下串口助手软件之间的双向通讯.
  10          //              本例缓冲为4个数字字符,缓冲满后新接收的字符从缓冲前面存放
  11          //              （环形缓冲）,覆盖原来放入的字符.
  12          //              如果发送的数字串中遇到"#"号则从缓冲起始位置开始存放.
  13          //
  14          //-----------------------------------------------------------------
  15          #include <reg52.h>
  16          #include <intrins.h>
  17          #include <stdio.h>
  18          #define INT8U  unsigned char
  19          #define INT16U unsigned int
  20          #define FREQ    11059200        //振荡器频率11.0592MHz
  21          INT8U code SEG_CODE[] =         //共阴数码管数字段码表,最后为"-"的段码
  22          { 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x40 };
  23          INT8U R[] = {10,10,10,10};      //保存接收到的四位数字(初始时为4个"-")
  24          //-----------------------------------------------------------------
  25          // 延时程序
  26          //-----------------------------------------------------------------
  27          void delay_ms(INT16U x) {INT8U t; while(x--) for(t = 0; t<120; t++);}
  28          //-----------------------------------------------------------------
  29          // 串口初始化(使用Timer1定时器)
  30          //-----------------------------------------------------------------
  31          void Init_USART_uT1()
  32          {
  33   1              SCON = 0x50;                                            //串口方式1
  34   1              TMOD = 0x20;                                            //T1工作于方式2（8位自动重装）
  35   1              PCON = 0x80;                                            //波特率不倍增
  36   1              TH1 = TL1 = - FREQ/384/9600;            //波特率配置（TH1 = TL1 = 0xFD）
  37   1              //或：TH1 = TL1 = 256 - FREQ/384/9600;
  38   1              TR1 = 1;                                                        //启动定时器T1
  39   1      }
  40          
  41          //-----------------------------------------------------------------
  42          // 串口初始化(使用T2定时器) (当T2CON寄存器的RCLK,TCLK二者之一置位,
  43          // T2即工作于波特率发生器模式，TH2-TL2溢出时，RCAP2H-RCAP2L重装TH2-TL2)
  44          //-----------------------------------------------------------------
  45          void Init_USART_uT2()
  46          {
  47   1              RCAP2H = 0xFF;                                          //波特率配置（RCAP2H = 0xFF）
  48   1              RCAP2L = -FREQ/32/9600;                         //波特率配置（RCAP2L = 0xDC）
  49   1              //或：RCAP2L = 256 - FREQ/32/9600;
  50   1              SCON = 0x50;                                            //串口方式1
  51   1              T2CON = 0x30;                                           //收发时钟位：RCLK,TCLK同时置位
  52   1              PCON = 0x00;                                            //波特率不倍增
  53   1              TR2 = 1;                                                        //启动定时器T2
  54   1      }
  55          
C51 COMPILER V9.02   MAIN                                                                  02/08/2020 17:48:11 PAGE 2   

  56          //-----------------------------------------------------------------
  57          // 主程序
  58          //-----------------------------------------------------------------
  59          void main()
  60          {
  61   1              INT8U i;                                                
  62   1              Init_USART_uT2();                               //串口初始化（使用Timer2定时器）
  63   1              //或：Init_USART_uT1();
  64   1              EX0 = 1;                                                //允许外部中断0
  65   1              IT0 = 1;                                                //下降沿触发
  66   1              ES = 1;                                                 //允许串口中断
  67   1              EA = 1;                                                 //开中断
  68   1              while(1)                                                
  69   1              {
  70   2                      for (i = 0; i < 4; i++)         //循环扫描显示4个数字字符
  71   2                      {
  72   3                              P0 = 0x00;                              //先暂时关闭段码
  73   3                              P2 = ~(1 << i);                 //发送位码（共阴）
  74   3                              P0 = SEG_CODE[R[i]];    //发送段码
  75   3                              delay_ms(4);                    //位间短暂延时
  76   3                      }
  77   2              }
  78   1      }
  79          
  80          //-----------------------------------------------------------------
  81          // 串口接收中断
  82          //-----------------------------------------------------------------
  83          void receive_4_digit() interrupt 4
  84          {
  85   1              static INT8U i = 0;                                     //接收缓冲索引（静态变量）
  86   1              INT8U c;                                                        //当前接收到的字符
  87   1              if (RI)                                                         //接收中断标志位判断
  88   1              {
  89   2                      RI = 0;                                                 //软件清零中断标志位
  90   2                      c = SBUF;                                               //从SBUF寄存器读取字符
  91   2                      if (c == '#')                                   //接收时遇到'#'则将接收索引清零
  92   2                              i = 0;
  93   2                      else                                                                       
  94   2                              if (c >= '0' && c <= '9')       //遇到数字0~9时从当前位置循环存放
  95   2                              {
  96   3                                      R[i++] = c - '0';               //存入R数组当前位置，索引递增
  97   3                                      if (i == 4)
  98   3                                              i = 0;                          //归0回头
  99   3                              }
 100   2              }
 101   1      }
 102          
 103          //-----------------------------------------------------------------
 104          // INT0中断发送字符串
 105          //-----------------------------------------------------------------
 106          void EX_INT0() interrupt 0 
 107          {
 108   1              INT8U *s = "这是由8051单片机发送的字符串!!!\r\n";
 109   1              INT8U i = 0;
 110   1              while( s[i] != '\0')
 111   1              {
 112   2                      SBUF = s[i++];           //发送1字节，索引递增
 113   2                      while(TI == 0);          //等待发送完毕
 114   2                      TI = 0;                          //软件清零中断标志位TI
 115   2              }
 116   1      
 117   1      
C51 COMPILER V9.02   MAIN                                                                  02/08/2020 17:48:11 PAGE 3   

 118   1      
 119   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    272    ----
   CONSTANT SIZE    =     45    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
