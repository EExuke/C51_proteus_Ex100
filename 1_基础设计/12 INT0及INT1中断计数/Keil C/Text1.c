//-----------------------------------------------------------------
//  名称: INT0及INT1 中断计数
//-----------------------------------------------------------------
//  说明: 每次按下第1个计数键时第1组计数值累加并显示在右边的三只管上
//		 每次按下第2个计数键时第2组计数值累加并显示在左边的三只管上
//			后两个按键分别清零  
//-----------------------------------------------------------------
#include <reg51.h>
#include <intrins.h>
#define INT8U  unsigned char
#define INT16U unsigned int
sbit K3 = P3^4;  //两个清零键
sbit K4 = P3^5;
INT8U code DSY_CODE[] = 
{0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xFF};//共阳数码管段码表
INT8U code Scan_BITs[] = {0x20,0x10,0x08,0x04,0x02,0x01};//6只数码管的位码；

//两组计数的显示缓冲,前三位为一组,后三位为另一组
INT8U data disp_buff[] = {0,0,0,0,0,0};
//两个计数值
INT16U Count_A = 0,Count_B = 0;
//-----------------------------------------------------------------
// 延时
//-----------------------------------------------------------------
void delay_ms(INT16U x) 
{
	INT8U t; while(x--) for(t = 0; t < 120; t++);
}
//-----------------------------------------------------------------
// 数据显示
//-----------------------------------------------------------------
void Show_Counts()
{
	INT8U i;
	/*分解计数值Count_A*/
	disp_buff[5] = Count_A / 100;	  	//百位；
	disp_buff[4] = Count_A % 100 / 10;	//十位；
	disp_buff[3] = Count_A % 10;		//个位；
	if(disp_buff[5] == 0 )	 		//高位为0时不显示；
	{
		disp_buff[5] = 10;
		if(disp_buff[4] == 0)
			disp_buff[4] = 10 ;
	}
	/*分解计数值Count_B*/
	disp_buff[2] = Count_B / 100;	  	//百位；
	disp_buff[1] = Count_B % 100 / 10;	//十位；
	disp_buff[0] = Count_B % 10;		//个位；
	if(disp_buff[2] == 0 )	 		//高位为0时不显示；
	{
		disp_buff[2] = 10;
		if(disp_buff[1] == 0)
			disp_buff[1] = 10 ;
	}
	/*数码管扫描显示*/
	for(i=0;i<6;i++)
	{
		P0 = 0xFF;				//暂时关闭段码；
		P2 = Scan_BITs[i];		//P2扫描位码；
		P0 = DSY_CODE[disp_buff[i]];		//P0输出段码；
		delay_ms(1);			
	}
}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main()
{	 
	IT0 = 1;		//INT0 下降沿触发；
	IT1 = 1;		//INT1 下降沿触发；
	PX0 = 1;		//设置优先级；
	IE = 0x85;		//INT0，INT1开中断；
	while(1)
	{
	 	if(!K3)	
			Count_A = 0;	//处理A组清零；
		if(!K4)
			Count_B = 0;	//处理B组清零；
		Show_Counts();
	}
}
//-----------------------------------------------------------------
// INT0中断
//-----------------------------------------------------------------
void EX_INT0() interrupt 0
{
	EA = 0;
	delay_ms(10);
	Count_A++;
	EA = 1;
}
//-----------------------------------------------------------------
// INT1中断
//-----------------------------------------------------------------
void EX_INT1() interrupt 2 
{
	EA = 0;
	delay_ms(10);
	Count_B++;
	EA = 1;	
}