//-----------------------------------------------------------------
//  名称: 按键调节数码管数字显示
//-----------------------------------------------------------------
//  说明: 本例通过按键加减数码管所显示的数字,调节过程中数码管闪烁显示.
//		 确定后恢复正常显示,按下取消时将恢复到调节之前的值.
//
//-----------------------------------------------------------------
#include <reg51.h>
#define INT8U	unsigned char
#define INT16U	unsigned int
//调节按键定义
sbit K1 = P3^4; //加
sbit K2 = P3^5; //减
sbit K3 = P3^6; //确定
sbit K4 = P3^7; //取消
//数字0~9的数码管段码表
INT8U code SEG_CODE[] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};
INT16U Count = 2900;            //初始显示值；
INT16U Temp;                    //临时变量；
INT8U  array[] = {0,0,0,0};        //保存数位分解结果的数组；
INT8U  Adjust = 0;                //标识当前是否处于调节状态；
INT8U  Pre_key = 0xF0;            //保存上次按键状态；





//-----------------------------------------------------------------
// 延时函数
//-----------------------------------------------------------------
void delay_ms(INT16U x) 
{
	INT8U t; while(x--) for(t = 0; t < 120; t++);
}

//-----------------------------------------------------------------
// 数位分解函数(分解为4个数位)
// 使用循环减法的分解速度优于使用/与%分解
//-----------------------------------------------------------------
void INT_TO_4Digit(INT16U n)
{
     array[0] = 0 ; while(n >= 1000) { array[0]++; n -= 1000;}
     array[1] = 0 ; while(n >= 100) { array[1]++; n -= 100;}
     array[2] = 0 ; while(n >= 10) { array[2]++; n -= 10;}
     array[3] = n ;
}

//-----------------------------------------------------------------
// 按键处理函数
//-----------------------------------------------------------------
void key_handle()
{
   P3 |= 0xF0;                        //P3高4位先置高电平；
   if(Pre_key == (P3 & 0xF0))        //按键状态未改变时返回继续；
           return;                        
   Pre_key = P3 & 0xF0;                //保存当前新的按键状态；
   //--------------------------------------------------------------
   if(!K1)          //递增，进入调节状态；
   {
           delay_ms(10);
        if(!K1)
        {
            if(Temp == 0)    Temp = Count;    //备份Temp，以便按下取消时还原；
            Count++;    Adjust = 1;            //Count递增，并进入调节状态；
        }
   }
   if(!K2)          //递减，进入调节状态；
   {
           delay_ms(10);
        if(!K2)
        {
            if(Temp == 0)    Temp = Count;    //备份Temp，以便按下取消时还原；
            Count--;    Adjust = 1;            //Count递减，并进入调节状态；
        }
   }
   if(!K3)          //确定，返回正常显示状态；
   {
           delay_ms(10);
        if(!K3)
        {
            Adjust = 0;    Temp = 0;
        }
   }
   if(!K4)          //取消，返回正常显示状态；
   {
           delay_ms(10);
        if(!K4)
        {
            if(Temp)    Count = Temp;       //还原Count，Temp清零；
            Temp = 0;    
            Adjust = 0;
        }
   }
}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main()
{
    INT8U i;    INT16U t;
    while(1)
    {    //1.正常刷新显示---------------------------------------------
        for(t=0;t<35;t++)                 //此循环用于保持数码管稳定显示；
        {                                
            INT_TO_4Digit(Count);        //数位分解；
            for(i=0;i<4;i++)            //4位数码管扫描刷新显示；
            {                            
                P0 = 0xFF;                //先暂时关闭段码（共阳数码管）；
                P3 = (P3 & 0xF0)|(1 << i);     //P3低4位为位码，高4位接按键；
                P0 = SEG_CODE[array[i]];     //发送段码；
                delay_ms(2);
            }
            key_handle();               //数字调节按键处理
        }
        //2.处于调节状态---------------------------------------------
         if(Adjust)                      //脱离了扫描刷新，数码管开始闪烁；
         {                              
             P0 = 0xFF;                  //关闭所有数码管；
            for(t=0;t<15;t++)          //在此循环中保持按键响应；
            {
                delay_ms(10);
                key_handle();
            }
         }        
    }
}