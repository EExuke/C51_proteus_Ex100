//-----------------------------------------------------------------
//  名称: INT0中断计数
//-----------------------------------------------------------------
//  说明: 每次按下计数键时触发INT0中断,中断程序累加计数,
//		计数值显示在三只数码管上,按下清零键时数码管清零.
//-----------------------------------------------------------------
#include <reg51.h>
#include <intrins.h>
#define INT8U  unsigned char
#define INT16U unsigned int
//0~9的数字编码,最后一位为黑屏
const INT8U SEG_CODE[] = 
{ 0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xFF };
//计数器值分解后的各待显示数位
INT8U Display_Buffer[3] = {0,0,0};

INT16U Count = 0;
sbit Clear_Key = P3^6;
//-----------------------------------------------------------------
// 延时
//-----------------------------------------------------------------
void delay_ms(INT16U x) 
{
	INT8U t; while(x--) for(t = 0; t < 120; t++);
}
//-----------------------------------------------------------------
// 在数码管上显示计数值
//-----------------------------------------------------------------
void Refresh_Display()
{  	/*---数位分解---*/
	Display_Buffer[0] =	Count / 100;	//百位；
	Display_Buffer[1] =	Count % 100 / 10 ;	//十位；
	Display_Buffer[2] = Count % 10;	    //个位；
	if(Display_Buffer[0] == 0)		//高位为0时，不显示；
	{
	 	Display_Buffer[0] =	10;		//显示黑屏；
		if(Display_Buffer[1] == 0)		//高位为零时，第二位为零也不显示；
			Display_Buffer[1] = 10;		//黑屏；		
	}
	P0 = SEG_CODE[Display_Buffer[0]];	//三只数码管独立显示；
	P1 = SEG_CODE[Display_Buffer[1]];
	P2 = SEG_CODE[Display_Buffer[2]];
} 
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main()
{  
	P0 = 0xFF; P1 = 0xFF; P2 = 0xFF; 	//初始化显示端口；
	IE = 0x81;					 //允许INT0中断,在P3.2口；
	IT0 = 1;					 //下降沿触发；
	while(1)
	{
	 	if(Clear_Key == 0)		//清零键按下，清零计数；
			Count = 0;
		Refresh_Display();		//持续刷新显示；
	}
}
//-----------------------------------------------------------------
// INT0中断函数				 （P3.2口触发中断函数）
//-----------------------------------------------------------------
void EX_INT0() interrupt 0 
{
	EA = 0;				//暂时关中断；
	delay_ms(10);		//延时消抖
	Count++;			//计数值递增；
	EA = 1;				//开中断；
}