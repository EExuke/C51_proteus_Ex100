//-----------------------------------------------------------------
//  名称: 串口发送数据到两片8x8点阵屏滚动显示
//-----------------------------------------------------------------
//  说明: 本例通过串口发送数据到3片串入并出芯片75HC595,前两片分别
//		  发送第一块和第二块点阵屏的行码,第三片负责两片点阵屏的列码.
//
//-----------------------------------------------------------------
#include <reg51.h> 
#include <intrins.h>
#include <stdio.h>
#define INT8U  unsigned char
#define INT16U unsigned int
sbit  ST_CP = P3^2;					//595输出锁存器控制线
INT8U code Arrow_Matrix[]=			//待显示图形的点阵
{
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xF7,0xE3,0x81,0x00,0xC3,0xC3,
  0xC3,0xC3,0xC3,0xC3,0xC3,0xE7,0xE7,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};
INT8U Offset,Idx = 0;
//-----------------------------------------------------------------
// 延时
//-----------------------------------------------------------------
void delay_ms( INT16U t )
{
	INT8U i;  while ( t-- ) for(i = 0; i < 120; i++);
}

//-----------------------------------------------------------------
// T0定时器中断控制点阵屏显示
//-----------------------------------------------------------------
void  T0_Led_Display_Control() interrupt 1 
{
	static INT8U Scan_BIT = 0x01;	//初始列码
	TH0 = -1000 >> 8; 				//重新装入1ms定时常数
	TL0 = -1000 & 0xFF;
	Scan_BIT = _cror_(Scan_BIT, 1);	//计算当前列码
	putchar(Scan_BIT);				//先通过串口发送列码
	while(TI == 0)					//等待串口输出完成
	{
		//发送两字节点阵编码（两字节行码）
		putchar(Arrow_Matrix[Offset + Idx + 8]);
		while(TI == 0);
		putchar(Arrow_Matrix[Offset + Idx]);
		while(TI == 0);
		ST_CP = 0;	//先置低电平
		ST_CP = 1;	//上升沿将数据送到输出锁存器
		ST_CP = 0;	//置低电平
		if (++Idx == 8)
			Idx = 0;	//下一次取数据的索引
	}
}

//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void  main()
{
	INT8U i;
	TMOD = 0x01;			//定时器T0工作方式1
	TH0 = -1000 >> 8;		//1ms定时常数
	TL0 = -1000 & 0xFF;
	IE = 0x82;				//允许定时器T0中断
	TCON = 0x00;			//设串口工作模式
	TI = 1;					//发送完成标志位置1
	while(1)
	{
		for(i=0; i<32; i++)		//32次滚动
		{
			Offset = i;		//从数组中取点阵的偏移值
			TR0 = 1;			//启动定时器，刷新显示
			//延时50ms，在此时间范围内由定时器中断显示信息
			//调节延时参数可以改变滚动速度
			delay_ms(50);
			TR0 = 0;
		}
	}
}