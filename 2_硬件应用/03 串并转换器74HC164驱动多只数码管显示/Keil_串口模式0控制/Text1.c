//-----------------------------------------------------------------
//  名称: 串口模式0控制74HC164驱动多只数码管显示
//-----------------------------------------------------------------
//  说明: 本例运行时,5只独立数码管在串入并出转换器74HC164的驱动下
//        独立显示5位数字，数码管的显示仅占用单片机2只引脚.
//
//-----------------------------------------------------------------
#include <reg51.h>
#include <intrins.h>
#define INT8U  unsigned char
#define INT16U unsigned int
//数码管段码表
const INT8U SEG_CODE[] = 
{ 0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xFF };
//数位分解所用的权值表
const INT16U m[] = {10000,1000,100,10};
INT16U val = 42950; 		//所演示的起始值
INT8U Buf[5];				//分解以后的存放缓冲
//-----------------------------------------------------------------
// 延时
//-----------------------------------------------------------------
void delay_ms(INT16U x)
{
	INT8U i; while(--x) for(i = 0;i < 120; i++) ;
}

//-----------------------------------------------------------------
// 将整数x分解为5个数位,存入数组d
//-----------------------------------------------------------------
void Decompose(INT16U x,INT8U d[])
{
    INT8U i;
    for (i = 0; i < 4; i++)
    {
        d[i] = 0;
        while(x >= m[i])
        {
            x -= m[i];
            d[i]++;
        }
    }
    d[4] = x;
}

//-----------------------------------------------------------------
// 8位字节逆转函数(例如10101101-->10110101)
// 不使用此函数时,需要修改电路,将数码管引脚与74HC164输出引脚逆向连接
//-----------------------------------------------------------------
INT8U invert(INT8U d)
{
    INT8U i, dat = 0x00;
    for(i=0; i<8; i++)
    {
        d <<= 1;
        if (CY)
            dat |= 1 << i;
    }
    return dat;
}

//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main()
{
    INT8U i;
    SCON = 0x00;                  //串口模式0，即移位寄存器输入/输出方式
    TI = 1;                                   //TI置1
    while(1)
    {
        Decompose(val, Buf);                   //分解待显示数据val
        for(i=4; i!=0xFF; i--)                 //通过串口串行输出各字段码
        {
            SBUF = invert(SEG_CODE[Buf[i]]);   //将段码逆转后通过串口输出
            while(TI == 0);                    //等待发送结束
            TI = 0;
        }
        delay_ms(500);
        ++val;
    }
}